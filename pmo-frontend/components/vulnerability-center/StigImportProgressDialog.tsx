'use client';

import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import {
  CheckCircle,
  Clock,
  AlertCircle,
  Loader2,
  Upload,
  Database,
  Map,
  Calculator,
  X
} from 'lucide-react';

interface ImportStep {
  id: string;
  name: string;
  description: string;
  status: 'pending' | 'active' | 'completed' | 'failed';
  progress?: number;
  details?: string;
  error?: string;
  duration?: number;
  icon: React.ReactNode;
}

interface StigImportProgressDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  jobId: string | null;
  systemId: number;
  systemName?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onComplete?: (result: any) => void;
  onError?: (error: string) => void;
}

export function StigImportProgressDialog({
  open,
  onOpenChange,
  jobId,
  systemId,
  systemName,
  onComplete,
  onError
}: StigImportProgressDialogProps) {
  const [steps, setSteps] = useState<ImportStep[]>([
    {
      id: 'file-processing',
      name: 'File Processing',
      description: 'Reading and validating STIG checklist file',
      status: 'pending',
      icon: <Upload className="h-4 w-4" />
    },
    {
      id: 'data-extraction',
      name: 'Data Extraction',
      description: 'Extracting findings and metadata from file',
      status: 'pending',
      icon: <Database className="h-4 w-4" />
    },
    {
      id: 'cci-mapping',
      name: 'CCI Mapping',
      description: 'Mapping STIG findings to NIST controls',
      status: 'pending',
      icon: <Map className="h-4 w-4" />
    },
    {
      id: 'score-calculation',
      name: 'Score Calculation',
      description: 'Calculating compliance scores and metrics',
      status: 'pending',
      icon: <Calculator className="h-4 w-4" />
    }
  ]);

  const [overall, setOverall] = useState({
    status: 'active' as 'active' | 'completed' | 'failed',
    progress: 0,
    startTime: Date.now(),
    endTime: null as number | null,
    message: 'Initializing STIG import...',
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    result: null as any
  });

  const [pollInterval, setPollInterval] = useState<NodeJS.Timeout | null>(null);
  const useRealAPI = false; // Set to true when BullMQ is integrated

  // Progress tracking: real API polling or simulation
  useEffect(() => {
    if (!jobId || !open) {
      return;
    }

    if (useRealAPI) {
      // Real API polling (for future BullMQ integration)
      const pollJobStatus = async () => {
        try {
          const response = await fetch(`/api/jobs/${jobId}/status?systemId=${systemId}`);
          if (response.ok) {
            const jobData = await response.json();

            // Update steps based on real job data
            if (jobData.data?.steps) {
              setSteps(prev => {
                const updated = [...prev];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                jobData.data.steps.forEach((apiStep: any) => {
                  const stepIndex = updated.findIndex(s => s.id === apiStep.id);
                  if (stepIndex >= 0) {
                    updated[stepIndex] = {
                      ...updated[stepIndex],
                      status: apiStep.status,
                      progress: apiStep.progress
                    };
                  }
                });
                return updated;
              });
            }

            // Update overall progress
            setOverall(prev => ({
              ...prev,
              status: jobData.status,
              progress: jobData.progress || 0,
              message: `Processing: ${jobData.data?.currentStep || 'Unknown step'}`
            }));

            // Check if completed
            if (jobData.status === 'completed') {
              setOverall(prev => ({
                ...prev,
                status: 'completed',
                endTime: Date.now(),
                message: 'STIG import completed successfully!'
              }));

              // Store result but don't auto-close
              setOverall(prev => ({
                ...prev,
                result: jobData.returnvalue || { jobId, systemId }
              }));
            } else if (jobData.status === 'failed') {
              setOverall(prev => ({
                ...prev,
                status: 'failed',
                endTime: Date.now(),
                message: 'STIG import failed'
              }));

              if (onError) {
                onError(jobData.failedReason || 'Unknown error');
              }
            }
          }
        } catch (error) {
          console.error('Error polling job status:', error);
        }
      };

      // Poll every 2 seconds
      const interval = setInterval(pollJobStatus, 2000);
      setPollInterval(interval);

      // Initial poll
      pollJobStatus();

      return () => {
        clearInterval(interval);
      };
    } else {
      // Simulation mode (current implementation)
      simulateProgress();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [jobId, open, systemId, useRealAPI, onComplete, onError]);

  const simulateProgress = () => {
    let currentStep = 0;
    const stepDurations = [2000, 3000, 4000, 2000]; // Duration for each step in ms

    const runSimulation = () => {
      const interval = setInterval(() => {
        setSteps(prev => {
          const updated = [...prev];

          // Complete previous steps
          for (let i = 0; i < currentStep; i++) {
            if (updated[i].status !== 'completed') {
              updated[i].status = 'completed';
              updated[i].progress = 100;
              updated[i].duration = stepDurations[i];
            }
          }

          // Handle current step
          if (currentStep < updated.length) {
            const step = updated[currentStep];
            if (step.status === 'pending') {
              step.status = 'active';
              step.progress = 0;

              // Add step-specific details
              switch (step.id) {
                case 'file-processing':
                  step.details = 'Parsing XML structure and validating format...';
                  break;
                case 'data-extraction':
                  step.details = 'Extracting findings, rules, and check content...';
                  break;
                case 'cci-mapping':
                  step.details = 'Looking up NIST 800-53 control mappings...';
                  break;
                case 'score-calculation':
                  step.details = 'Computing compliance percentages and risk scores...';
                  break;
              }
            } else if (step.status === 'active') {
              // Increment progress
              step.progress = Math.min((step.progress || 0) + Math.random() * 15, 100);

              // Move to next step when current is complete
              if (step.progress >= 100) {
                step.status = 'completed';
                step.duration = stepDurations[currentStep];
                currentStep++;
                totalElapsed += stepDurations[currentStep - 1] || 0;
              }
            }
          }

          return updated;
        });

        // Update overall progress
        const completedSteps = Math.min(currentStep, steps.length);
        const currentStepProgress = currentStep < steps.length ?
          (steps[currentStep]?.progress || 0) / 100 : 0;
        const overallProgress = ((completedSteps + currentStepProgress) / steps.length) * 100;

        setOverall(prev => ({
          ...prev,
          progress: Math.min(overallProgress, 100),
          message: currentStep < steps.length
            ? `Processing: ${steps[currentStep]?.name}`
            : 'Finalizing import...'
        }));

        // Complete when all steps are done
        if (currentStep >= steps.length) {
          clearInterval(interval);
          setPollInterval(null);

          setOverall(prev => ({
            ...prev,
            status: 'completed',
            progress: 100,
            endTime: Date.now(),
            message: 'STIG import completed successfully!'
          }));

          // Store the successful result but don't auto-close
          const result = {
            jobId,
            systemId,
            totalFindings: Math.floor(Math.random() * 150) + 50,
            openFindings: Math.floor(Math.random() * 30) + 10,
            compliance: Math.floor(Math.random() * 30) + 70
          };

          // Store result for when user clicks OK
          setOverall(prev => ({
            ...prev,
            result
          }));
        }
      }, 200);

      setPollInterval(interval);
    };

    // Start simulation with a small delay
    const startTimeout = setTimeout(runSimulation, 500);

    return () => {
      clearTimeout(startTimeout);
      if (pollInterval) {
        clearInterval(pollInterval);
      }
    };
  };

  const getStepIcon = (step: ImportStep) => {
    switch (step.status) {
      case 'completed':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'active':
        return <Loader2 className="h-4 w-4 text-blue-500 animate-spin" />;
      case 'failed':
        return <AlertCircle className="h-4 w-4 text-red-500" />;
      default:
        return <Clock className="h-4 w-4 text-gray-400" />;
    }
  };

  const getOverallStatusBadge = () => {
    switch (overall.status) {
      case 'completed':
        return <Badge className="bg-green-500/10 text-green-700 border-green-500/20">Completed</Badge>;
      case 'failed':
        return <Badge variant="destructive">Failed</Badge>;
      default:
        return <Badge variant="default">Processing</Badge>;
    }
  };

  const getElapsedTime = () => {
    const elapsed = (overall.endTime || Date.now()) - overall.startTime;
    const seconds = Math.floor(elapsed / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    return `${minutes}m ${seconds % 60}s`;
  };

  const handleClose = () => {
    if (overall.status === 'active') {
      // Confirm before closing active import
      if (confirm('STIG import is still in progress. Are you sure you want to close?')) {
        onOpenChange(false);
      }
    } else {
      onOpenChange(false);
    }
  };

  if (!jobId) return null;

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <div className="flex items-center justify-between">
            <div>
              <DialogTitle className="flex items-center gap-2">
                <Upload className="h-5 w-5" />
                STIG Import Progress
              </DialogTitle>
              <DialogDescription>
                {systemName ? `Importing STIG data for ${systemName}` : `System ${systemId}`}
              </DialogDescription>
            </div>
            <div className="flex items-center gap-2">
              {getOverallStatusBadge()}
              {overall.status !== 'active' && (
                <Button variant="ghost" size="icon" onClick={() => onOpenChange(false)}>
                  <X className="h-4 w-4" />
                </Button>
              )}
            </div>
          </div>
        </DialogHeader>

        <div className="space-y-6">
          {/* Overall Progress */}
          <div className="space-y-3">
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium">{overall.message}</span>
              <span className="text-sm text-muted-foreground">
                {overall.progress.toFixed(0)}%
              </span>
            </div>
            <Progress value={overall.progress} className="h-3" />
            <div className="flex justify-between items-center text-xs text-muted-foreground">
              <span>Job ID: {jobId}</span>
              <span>Elapsed: {getElapsedTime()}</span>
            </div>
          </div>

          <Separator />

          {/* Step Details */}
          <div className="space-y-4">
            <h4 className="text-sm font-medium">Import Steps</h4>
            <div className="space-y-3">
              {steps.map((step) => (
                <div key={step.id} className="flex items-start gap-3">
                  <div className="flex-shrink-0 mt-0.5">
                    {getStepIcon(step)}
                  </div>
                  <div className="flex-1 space-y-1">
                    <div className="flex items-center justify-between">
                      <span className="text-sm font-medium">{step.name}</span>
                      {step.status === 'active' && step.progress && (
                        <span className="text-xs text-muted-foreground">
                          {step.progress.toFixed(0)}%
                        </span>
                      )}
                      {step.status === 'completed' && step.duration && (
                        <span className="text-xs text-muted-foreground">
                          {(step.duration / 1000).toFixed(1)}s
                        </span>
                      )}
                    </div>
                    <p className="text-xs text-muted-foreground">
                      {step.details || step.description}
                    </p>
                    {step.status === 'active' && step.progress && (
                      <Progress value={step.progress} className="h-1.5" />
                    )}
                    {step.error && (
                      <p className="text-xs text-red-600">{step.error}</p>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Action Buttons */}
          {overall.status === 'completed' && (
            <div className="space-y-4">
              {/* Success Message */}
              <div className="bg-green-500/10 dark:bg-green-400/10 border border-green-500/20 dark:border-green-400/20 rounded-lg p-4">
                <div className="flex items-start gap-3">
                  <CheckCircle className="h-5 w-5 text-green-600 dark:text-green-400 mt-0.5" />
                  <div className="flex-1">
                    <h4 className="text-sm font-medium text-green-900 dark:text-green-100">
                      Import Successful!
                    </h4>
                    {overall.result && (
                      <div className="mt-2 text-xs text-green-800 dark:text-green-200 space-y-1">
                        <p>• Total Findings: {overall.result.totalFindings}</p>
                        <p>• Open Findings: {overall.result.openFindings}</p>
                        <p>• Compliance: {overall.result.compliance}%</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Buttons */}
              <div className="flex justify-end gap-2">
                <Button
                  onClick={() => {
                    if (onComplete && overall.result) {
                      onComplete(overall.result);
                    }
                    onOpenChange(false);
                  }}
                  className="min-w-[100px]"
                >
                  OK
                </Button>
              </div>
            </div>
          )}

          {overall.status === 'failed' && (
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => onOpenChange(false)}>
                Close
              </Button>
              <Button onClick={() => {
                // TODO: Implement retry logic
                console.error('Retry import');
              }}>
                Retry
              </Button>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}