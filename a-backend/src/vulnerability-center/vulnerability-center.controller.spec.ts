import { Test, TestingModule } from '@nestjs/testing';
import { BadRequestException } from '@nestjs/common';
import { VulnerabilityCenterController } from './vulnerability-center.controller';
import { VulnerabilityCenterService } from './vulnerability-center.service';

describe('VulnerabilityCenterController', () => {
  let controller: VulnerabilityCenterController;
  let service: VulnerabilityCenterService;

  const mockService = {
    importStigScan: jest.fn(),
    getStigScans: jest.fn(),
    getStigFindings: jest.fn(),
    updateFindingStatus: jest.fn(),
    getSystemScore: jest.fn(),
    getControlSystemStatus: jest.fn(),
    createStp: jest.fn(),
    getJobStatus: jest.fn(),
    getGroupScore: jest.fn(),
    getPackageScore: jest.fn(),
    getPackageStats: jest.fn(),
    getControlGroupStatus: jest.fn(),
    getControlPackageStatus: jest.fn(),
    recalculateGroupScore: jest.fn(),
    recalculatePackageScore: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [VulnerabilityCenterController],
      providers: [
        {
          provide: VulnerabilityCenterService,
          useValue: mockService,
        },
      ],
    }).compile();

    controller = module.get<VulnerabilityCenterController>(VulnerabilityCenterController);
    service = module.get<VulnerabilityCenterService>(VulnerabilityCenterService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('importStigScan', () => {
    it('should import STIG scan with .ckl file', async () => {
      const mockFile = {
        originalname: 'scan.ckl',
        mimetype: 'application/xml',
        buffer: Buffer.from('<CHECKLIST></CHECKLIST>'),
      } as Express.Multer.File;

      const mockRequest = { user: { id: 1 } };

      mockService.importStigScan.mockResolvedValue({ jobId: 'job-123' });

      const result = await controller.importStigScan(1, mockFile, mockRequest);

      expect(result).toEqual({ jobId: 'job-123' });
      expect(service.importStigScan).toHaveBeenCalledWith(
        1,
        'scan.ckl',
        '<CHECKLIST></CHECKLIST>',
        1,
      );
    });

    it('should import STIG scan with .cklb file', async () => {
      const mockFile = {
        originalname: 'scan.cklb',
        mimetype: 'application/json',
        buffer: Buffer.from('{"stigs": []}'),
      } as Express.Multer.File;

      const mockRequest = { user: { id: 2 } };

      mockService.importStigScan.mockResolvedValue({ jobId: 'job-456' });

      const result = await controller.importStigScan(1, mockFile, mockRequest);

      expect(result).toEqual({ jobId: 'job-456' });
      expect(service.importStigScan).toHaveBeenCalledWith(
        1,
        'scan.cklb',
        '{"stigs": []}',
        2,
      );
    });

    it('should throw BadRequestException when no file uploaded', async () => {
      const mockRequest = { user: { id: 1 } };

      await expect(
        controller.importStigScan(1, undefined as any, mockRequest),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException for invalid file extension', async () => {
      const mockFile = {
        originalname: 'scan.txt',
        mimetype: 'text/plain',
        buffer: Buffer.from('test'),
      } as Express.Multer.File;

      const mockRequest = { user: { id: 1 } };

      await expect(
        controller.importStigScan(1, mockFile, mockRequest),
      ).rejects.toThrow(BadRequestException);
    });

    it('should default to user ID 1 when not authenticated', async () => {
      const mockFile = {
        originalname: 'scan.ckl',
        mimetype: 'application/xml',
        buffer: Buffer.from('<CHECKLIST></CHECKLIST>'),
      } as Express.Multer.File;

      const mockRequest = {};

      mockService.importStigScan.mockResolvedValue({ jobId: 'job-789' });

      await controller.importStigScan(1, mockFile, mockRequest);

      expect(service.importStigScan).toHaveBeenCalledWith(
        1,
        'scan.ckl',
        '<CHECKLIST></CHECKLIST>',
        1,
      );
    });
  });

  describe('getStigScans', () => {
    it('should return STIG scans for a system', async () => {
      const mockScans = [
        { id: 1, filename: 'scan1.ckl', systemId: 1 },
        { id: 2, filename: 'scan2.cklb', systemId: 1 },
      ];

      mockService.getStigScans.mockResolvedValue(mockScans);

      const result = await controller.getStigScans(1);

      expect(result).toEqual(mockScans);
      expect(service.getStigScans).toHaveBeenCalledWith(1);
    });
  });

  describe('getStigFindings', () => {
    it('should return findings with default pagination', async () => {
      const mockResult = {
        findings: [],
        pagination: { page: 1, limit: 50, total: 0, pages: 0 },
      };

      mockService.getStigFindings.mockResolvedValue(mockResult);

      const result = await controller.getStigFindings(1);

      expect(result).toEqual(mockResult);
      expect(service.getStigFindings).toHaveBeenCalledWith(1, undefined, 1, 50, {});
    });

    it('should return findings with filters', async () => {
      const mockResult = {
        findings: [{ id: 1, status: 'Open', severity: 'CAT_I' }],
        pagination: { page: 1, limit: 20, total: 1, pages: 1 },
      };

      mockService.getStigFindings.mockResolvedValue(mockResult);

      const result = await controller.getStigFindings(
        1,
        '123',
        '1',
        '20',
        'Open',
        'CAT_I',
        'AC-1',
        'firewall',
      );

      expect(result).toEqual(mockResult);
      expect(service.getStigFindings).toHaveBeenCalledWith(1, 123, 1, 20, {
        status: 'Open',
        severity: 'CAT_I',
        controlId: 'AC-1',
        search: 'firewall',
      });
    });
  });

  describe('updateFindingStatus', () => {
    it('should update finding status', async () => {
      const mockUpdated = {
        id: 1,
        status: 'NotAFinding',
        justification: 'False positive',
      };

      mockService.updateFindingStatus.mockResolvedValue(mockUpdated);

      const mockRequest = { user: { id: 1 } };

      const result = await controller.updateFindingStatus(
        1,
        { status: 'NotAFinding', justification: 'False positive' },
        mockRequest,
      );

      expect(result).toEqual(mockUpdated);
      expect(service.updateFindingStatus).toHaveBeenCalledWith(
        1,
        'NotAFinding',
        'False positive',
        1,
      );
    });

    it('should update status without justification', async () => {
      const mockUpdated = { id: 1, status: 'Open' };

      mockService.updateFindingStatus.mockResolvedValue(mockUpdated);

      const mockRequest = { user: { id: 2 } };

      await controller.updateFindingStatus(1, { status: 'Open' }, mockRequest);

      expect(service.updateFindingStatus).toHaveBeenCalledWith(1, 'Open', undefined, 2);
    });
  });

  describe('getSystemScore', () => {
    it('should return system score', async () => {
      const mockScore = { systemId: 1, overallScore: 85 };

      mockService.getSystemScore.mockResolvedValue(mockScore);

      const result = await controller.getSystemScore(1);

      expect(result).toEqual(mockScore);
      expect(service.getSystemScore).toHaveBeenCalledWith(1, undefined);
    });

    it('should return system score for specific scan', async () => {
      const mockScore = { systemId: 1, scanId: 123, overallScore: 90 };

      mockService.getSystemScore.mockResolvedValue(mockScore);

      const result = await controller.getSystemScore(1, '123');

      expect(result).toEqual(mockScore);
      expect(service.getSystemScore).toHaveBeenCalledWith(1, 123);
    });
  });

  describe('getControlSystemStatus', () => {
    it('should return control system status', async () => {
      const mockStatus = [
        { controlId: 'AC-1', systemId: 1, status: 'Compliant' },
      ];

      mockService.getControlSystemStatus.mockResolvedValue(mockStatus);

      const result = await controller.getControlSystemStatus(1);

      expect(result).toEqual(mockStatus);
      expect(service.getControlSystemStatus).toHaveBeenCalledWith(1);
    });
  });

  describe('createStp', () => {
    it('should create STP from findings', async () => {
      const mockStp = { id: 1, name: 'Security Test Plan', systemId: 1 };

      mockService.createStp.mockResolvedValue(mockStp);

      const mockRequest = { user: { id: 1 } };

      const result = await controller.createStp(
        1,
        { name: 'Security Test Plan', findingIds: [1, 2, 3] },
        mockRequest,
      );

      expect(result).toEqual(mockStp);
      expect(service.createStp).toHaveBeenCalledWith(
        1,
        'Security Test Plan',
        [1, 2, 3],
        1,
      );
    });
  });

  describe('getJobStatus', () => {
    it('should return job status', async () => {
      const mockJobStatus = {
        id: 'job-123',
        name: 'import-stig-scan',
        progress: 100,
      };

      mockService.getJobStatus.mockResolvedValue(mockJobStatus);

      const result = await controller.getJobStatus('job-123');

      expect(result).toEqual(mockJobStatus);
      expect(service.getJobStatus).toHaveBeenCalledWith('job-123');
    });
  });

  describe('getGroupScore', () => {
    it('should return group score', async () => {
      const mockScore = { groupId: 1, overallScore: 80 };

      mockService.getGroupScore.mockResolvedValue(mockScore);

      const result = await controller.getGroupScore(1);

      expect(result).toEqual(mockScore);
      expect(service.getGroupScore).toHaveBeenCalledWith(1);
    });
  });

  describe('getPackageScore', () => {
    it('should return package score', async () => {
      const mockScore = { packageId: 1, overallScore: 75 };

      mockService.getPackageScore.mockResolvedValue(mockScore);

      const result = await controller.getPackageScore(1);

      expect(result).toEqual(mockScore);
      expect(service.getPackageScore).toHaveBeenCalledWith(1);
    });
  });

  describe('getPackageStats', () => {
    it('should return package statistics', async () => {
      const mockStats = {
        packageId: 1,
        totalSystems: 5,
        totalFindings: 100,
      };

      mockService.getPackageStats.mockResolvedValue(mockStats);

      const result = await controller.getPackageStats(1);

      expect(result).toEqual(mockStats);
      expect(service.getPackageStats).toHaveBeenCalledWith(1);
    });
  });

  describe('getControlGroupStatus', () => {
    it('should return control group status', async () => {
      const mockStatus = [
        { controlId: 'AC-1', groupId: 1, status: 'Partial' },
      ];

      mockService.getControlGroupStatus.mockResolvedValue(mockStatus);

      const result = await controller.getControlGroupStatus(1);

      expect(result).toEqual(mockStatus);
      expect(service.getControlGroupStatus).toHaveBeenCalledWith(1);
    });
  });

  describe('getControlPackageStatus', () => {
    it('should return control package status', async () => {
      const mockStatus = [
        { controlId: 'AC-1', packageId: 1, status: 'NonCompliant' },
      ];

      mockService.getControlPackageStatus.mockResolvedValue(mockStatus);

      const result = await controller.getControlPackageStatus(1);

      expect(result).toEqual(mockStatus);
      expect(service.getControlPackageStatus).toHaveBeenCalledWith(1);
    });
  });

  describe('recalculateGroupScore', () => {
    it('should recalculate group score', async () => {
      const mockResult = { groupId: 1, score: 82, status: 'success' };

      mockService.recalculateGroupScore.mockResolvedValue(mockResult);

      const result = await controller.recalculateGroupScore(1);

      expect(result).toEqual(mockResult);
      expect(service.recalculateGroupScore).toHaveBeenCalledWith(1);
    });
  });

  describe('recalculatePackageScore', () => {
    it('should recalculate package score', async () => {
      const mockResult = { packageId: 1, score: 78, status: 'success' };

      mockService.recalculatePackageScore.mockResolvedValue(mockResult);

      const result = await controller.recalculatePackageScore(1);

      expect(result).toEqual(mockResult);
      expect(service.recalculatePackageScore).toHaveBeenCalledWith(1);
    });
  });
});
