import { Test, TestingModule } from '@nestjs/testing';
import { NotFoundException } from '@nestjs/common';
import { getQueueToken } from '@nestjs/bullmq';
import { VulnerabilityCenterService } from './vulnerability-center.service';
import { PrismaService } from '../prisma/prisma.service';
import { ScoringService } from '../services/scoring.service';

describe('VulnerabilityCenterService', () => {
  let service: VulnerabilityCenterService;
  let prisma: PrismaService;
  let scoringService: ScoringService;

  const mockPrismaService = {
    system: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
    },
    stigScan: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
    },
    stigFinding: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      count: jest.fn(),
      groupBy: jest.fn(),
    },
    systemScore: {
      findFirst: jest.fn(),
      findMany: jest.fn(),
    },
    controlSystemStatus: {
      findMany: jest.fn(),
    },
    controlGroupStatus: {
      findMany: jest.fn(),
    },
    controlPackageStatus: {
      findMany: jest.fn(),
    },
    groupScore: {
      findFirst: jest.fn(),
    },
    packageScore: {
      findFirst: jest.fn(),
    },
    group: {
      findUnique: jest.fn(),
    },
    package: {
      findUnique: jest.fn(),
    },
    stp: {
      create: jest.fn(),
    },
    testCase: {
      createMany: jest.fn(),
    },
    $transaction: jest.fn(),
  };

  const mockStigImportQueue = {
    add: jest.fn(),
    getJob: jest.fn(),
  };

  const mockCciMappingQueue = {
    add: jest.fn(),
  };

  const mockScoringService = {
    calculateSystemScore: jest.fn(),
    calculateGroupScore: jest.fn(),
    calculatePackageScore: jest.fn(),
    updateControlSystemStatus: jest.fn(),
    updateControlGroupStatus: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        VulnerabilityCenterService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: ScoringService,
          useValue: mockScoringService,
        },
        {
          provide: getQueueToken('stig-import'),
          useValue: mockStigImportQueue,
        },
        {
          provide: getQueueToken('cci-mapping'),
          useValue: mockCciMappingQueue,
        },
      ],
    }).compile();

    service = module.get<VulnerabilityCenterService>(VulnerabilityCenterService);
    prisma = module.get<PrismaService>(PrismaService);
    scoringService = module.get<ScoringService>(ScoringService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('importStigScan', () => {
    it('should create STIG import job for valid system', async () => {
      const mockSystem = { id: 1, name: 'Test System' };
      const mockJob = { id: 'job-123' };

      mockPrismaService.system.findUnique.mockResolvedValue(mockSystem);
      mockStigImportQueue.add.mockResolvedValue(mockJob);

      const result = await service.importStigScan(
        1,
        'scan.ckl',
        '<CHECKLIST></CHECKLIST>',
        1,
      );

      expect(result).toEqual({ jobId: 'job-123' });
      expect(prisma.system.findUnique).toHaveBeenCalledWith({ where: { id: 1 } });
      expect(mockStigImportQueue.add).toHaveBeenCalledWith(
        'import-stig-scan',
        {
          systemId: 1,
          filename: 'scan.ckl',
          fileContent: '<CHECKLIST></CHECKLIST>',
          userId: 1,
        },
        expect.objectContaining({
          removeOnComplete: 100,
          removeOnFail: 500,
          attempts: 3,
        }),
      );
    });

    it('should throw NotFoundException for invalid system', async () => {
      mockPrismaService.system.findUnique.mockResolvedValue(null);

      await expect(
        service.importStigScan(999, 'scan.ckl', '<CHECKLIST></CHECKLIST>', 1),
      ).rejects.toThrow(NotFoundException);
    });
  });

  describe('getStigScans', () => {
    it('should return STIG scans for a system', async () => {
      const mockScans = [
        {
          id: 1,
          systemId: 1,
          filename: 'scan1.ckl',
          importer: { id: 1, firstName: 'John', lastName: 'Doe', email: 'john@test.com' },
          systemScores: [],
          _count: { stigFindings: 50 },
        },
      ];

      mockPrismaService.stigScan.findMany.mockResolvedValue(mockScans);

      const result = await service.getStigScans(1);

      expect(result).toEqual(mockScans);
      expect(prisma.stigScan.findMany).toHaveBeenCalledWith({
        where: { systemId: 1 },
        include: expect.objectContaining({
          importer: expect.any(Object),
          systemScores: true,
          _count: expect.any(Object),
        }),
        orderBy: { createdAt: 'desc' },
      });
    });
  });

  describe('getStigFindings', () => {
    it('should return findings with pagination', async () => {
      const mockFindings = [
        { id: 1, ruleId: 'SV-123', status: 'Open', severity: 'CAT_I' },
      ];

      mockPrismaService.stigFinding.findMany.mockResolvedValue(mockFindings);
      mockPrismaService.stigFinding.count.mockResolvedValue(1);

      const result = await service.getStigFindings(1);

      expect(result).toEqual({
        findings: mockFindings,
        pagination: {
          page: 1,
          limit: 50,
          total: 1,
          pages: 1,
        },
      });
    });

    it('should apply filters correctly', async () => {
      mockPrismaService.stigFinding.findMany.mockResolvedValue([]);
      mockPrismaService.stigFinding.count.mockResolvedValue(0);

      await service.getStigFindings(1, 123, 1, 20, {
        status: 'Open',
        severity: 'CAT_I',
        controlId: 'AC-1',
        search: 'firewall',
      });

      expect(prisma.stigFinding.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            systemId: 1,
            scanId: 123,
            status: 'Open',
            severity: 'CAT_I',
            controlId: 'AC-1',
            OR: expect.any(Array),
          }),
        }),
      );
    });

    it('should cap limit at 10000', async () => {
      mockPrismaService.stigFinding.findMany.mockResolvedValue([]);
      mockPrismaService.stigFinding.count.mockResolvedValue(0);

      await service.getStigFindings(1, undefined, 1, 20000);

      expect(prisma.stigFinding.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          take: 10000,
        }),
      );
    });
  });

  describe('updateFindingStatus', () => {
    it('should update finding status', async () => {
      const mockFinding = { id: 1, status: 'Open' };
      const mockUpdated = { id: 1, status: 'NotAFinding', justification: 'False positive' };

      mockPrismaService.stigFinding.findUnique.mockResolvedValue(mockFinding);
      mockPrismaService.stigFinding.update.mockResolvedValue(mockUpdated);

      const result = await service.updateFindingStatus(1, 'NotAFinding', 'False positive', 1);

      expect(result).toEqual(mockUpdated);
      expect(prisma.stigFinding.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: {
          status: 'NotAFinding',
          justification: 'False positive',
          reviewedAt: expect.any(Date),
          reviewedBy: 1,
        },
      });
    });

    it('should throw NotFoundException for invalid finding', async () => {
      mockPrismaService.stigFinding.findUnique.mockResolvedValue(null);

      await expect(
        service.updateFindingStatus(999, 'Open'),
      ).rejects.toThrow(NotFoundException);
    });
  });

  describe('getSystemScore', () => {
    it('should return latest system score', async () => {
      const mockScore = {
        id: 1,
        systemId: 1,
        overallScore: 85,
        calculatedAt: new Date(),
      };

      mockPrismaService.systemScore.findFirst.mockResolvedValue(mockScore);

      const result = await service.getSystemScore(1);

      expect(result).toEqual(mockScore);
      expect(prisma.systemScore.findFirst).toHaveBeenCalledWith({
        where: { systemId: 1 },
        orderBy: { calculatedAt: 'desc' },
        include: expect.objectContaining({
          scan: expect.any(Object),
        }),
      });
    });

    it('should return score for specific scan', async () => {
      const mockScore = {
        id: 1,
        systemId: 1,
        scanId: 123,
        overallScore: 90,
      };

      mockPrismaService.systemScore.findFirst.mockResolvedValue(mockScore);

      await service.getSystemScore(1, 123);

      expect(prisma.systemScore.findFirst).toHaveBeenCalledWith(
        expect.objectContaining({
          where: { systemId: 1, scanId: 123 },
        }),
      );
    });
  });

  describe('getControlSystemStatus', () => {
    it('should return control system status', async () => {
      const mockStatus = [
        { id: 1, controlId: 'AC-1', systemId: 1, status: 'Compliant' },
      ];

      mockPrismaService.controlSystemStatus.findMany.mockResolvedValue(mockStatus);

      const result = await service.getControlSystemStatus(1);

      expect(result).toEqual(mockStatus);
      expect(prisma.controlSystemStatus.findMany).toHaveBeenCalledWith({
        where: { systemId: 1 },
        orderBy: { controlId: 'asc' },
      });
    });
  });

  describe('getJobStatus', () => {
    it('should return job status', async () => {
      const mockJob = {
        id: 'job-123',
        name: 'import-stig-scan',
        progress: 50,
        processedOn: Date.now(),
        finishedOn: null,
        failedReason: null,
        returnvalue: null,
        opts: {},
        data: {},
      };

      mockStigImportQueue.getJob.mockResolvedValue(mockJob);

      const result = await service.getJobStatus('job-123');

      expect(result).toEqual({
        id: 'job-123',
        name: 'import-stig-scan',
        progress: 50,
        processedOn: mockJob.processedOn,
        finishedOn: null,
        failedReason: null,
        returnvalue: null,
        opts: {},
        data: {},
      });
    });

    it('should throw NotFoundException for invalid job', async () => {
      mockStigImportQueue.getJob.mockResolvedValue(null);

      await expect(service.getJobStatus('invalid-job')).rejects.toThrow(NotFoundException);
    });
  });

  describe('createStp', () => {
    it('should create STP from findings', async () => {
      const mockFindings = [
        { id: 1, ruleId: 'SV-1', ruleTitle: 'Test Rule 1' },
        { id: 2, ruleId: 'SV-2', ruleTitle: 'Test Rule 2' },
      ];

      const mockStp = {
        id: 1,
        name: 'Security Test Plan',
        systemId: 1,
        createdBy: 1,
      };

      mockPrismaService.stigFinding.findMany.mockResolvedValue(mockFindings);
      mockPrismaService.$transaction.mockImplementation((callback) => {
        const tx = {
          stp: { create: jest.fn().mockResolvedValue(mockStp) },
          testCase: { createMany: jest.fn() },
          stigFinding: { updateMany: jest.fn() },
        };
        return callback(tx);
      });

      const result = await service.createStp(1, 'Security Test Plan', [1, 2], 1);

      expect(result).toEqual(mockStp);
      expect(prisma.stigFinding.findMany).toHaveBeenCalledWith({
        where: {
          id: { in: [1, 2] },
          systemId: 1,
          status: { in: ['Open', 'Not_Reviewed'] },
        },
      });
    });
  });

  describe('getGroupScore', () => {
    it('should return group score', async () => {
      const mockScore = {
        id: 1,
        groupId: 1,
        overallScore: 80,
      };

      mockPrismaService.groupScore.findFirst.mockResolvedValue(mockScore);

      const result = await service.getGroupScore(1);

      expect(result).toEqual(mockScore);
    });
  });

  describe('getPackageScore', () => {
    it('should return package score', async () => {
      const mockScore = {
        id: 1,
        packageId: 1,
        overallScore: 75,
      };

      mockPrismaService.packageScore.findFirst.mockResolvedValue(mockScore);

      const result = await service.getPackageScore(1);

      expect(result).toEqual(mockScore);
    });
  });

  describe('getPackageStats', () => {
    it('should return package statistics', async () => {
      const mockSystems = [{ id: 1 }, { id: 2 }];
      const mockScores = [
        { systemId: 1, overallScore: 80 },
        { systemId: 2, overallScore: 90 },
      ];
      const mockGroupBy = [
        { severity: 'CAT_I', _count: { _all: 5 } },
        { severity: 'CAT_II', _count: { _all: 10 } },
      ];

      mockPrismaService.system.findMany.mockResolvedValue(mockSystems);
      mockPrismaService.systemScore.findMany.mockResolvedValue(mockScores);
      mockPrismaService.stigFinding.groupBy.mockResolvedValue(mockGroupBy);

      const result = await service.getPackageStats(1);

      expect(result).toBeDefined();
      expect(prisma.system.findMany).toHaveBeenCalled();
    });
  });

  describe('getControlGroupStatus', () => {
    it('should return control group status', async () => {
      const mockStatus = [
        { id: 1, controlId: 'AC-1', groupId: 1, status: 'Partial' },
      ];

      mockPrismaService.controlGroupStatus.findMany.mockResolvedValue(mockStatus);

      const result = await service.getControlGroupStatus(1);

      expect(result).toEqual(mockStatus);
    });
  });

  describe('getControlPackageStatus', () => {
    it('should return control package status', async () => {
      const mockStatus = [
        { id: 1, controlId: 'AC-1', packageId: 1, status: 'NonCompliant' },
      ];

      mockPrismaService.controlPackageStatus.findMany.mockResolvedValue(mockStatus);

      const result = await service.getControlPackageStatus(1);

      expect(result).toEqual(mockStatus);
    });
  });

  describe('recalculateGroupScore', () => {
    it('should recalculate group score', async () => {
      const mockGroup = { id: 1, name: 'Test Group', systems: [{ id: 1 }, { id: 2 }] };
      const mockScore = { groupId: 1, overallScore: 82 };
      const expectedResult = {
        success: true,
        message: 'Group score recalculated for group 1',
        systemsProcessed: 2,
      };

      mockPrismaService.group.findUnique.mockResolvedValue(mockGroup);
      mockScoringService.calculateSystemScore.mockResolvedValue({});
      mockScoringService.updateControlSystemStatus.mockResolvedValue({});
      mockScoringService.updateControlGroupStatus.mockResolvedValue({});
      mockScoringService.calculateGroupScore.mockResolvedValue(mockScore);

      const result = await service.recalculateGroupScore(1);

      expect(result).toEqual(expectedResult);
      expect(scoringService.calculateGroupScore).toHaveBeenCalledWith(1);
    });

    it('should throw NotFoundException for invalid group', async () => {
      mockPrismaService.group.findUnique.mockResolvedValue(null);

      await expect(service.recalculateGroupScore(999)).rejects.toThrow(NotFoundException);
    });
  });

  describe('recalculatePackageScore', () => {
    it('should recalculate package score', async () => {
      const mockPackage = {
        id: 1,
        name: 'Test Package',
        groups: [{ id: 1 }, { id: 2 }],
        systems: [{ id: 1 }, { id: 2 }, { id: 3 }],
      };
      const mockScore = { packageId: 1, overallScore: 78 };
      const mockGroup = { id: 1, name: 'Group 1', systems: [] };
      const expectedResult = {
        success: true,
        message: 'Package score recalculated for package 1',
        groupsProcessed: 2,
        systemsProcessed: 3,
      };

      mockPrismaService.package.findUnique.mockResolvedValue(mockPackage);
      mockPrismaService.group.findUnique.mockResolvedValue(mockGroup);
      mockScoringService.calculateGroupScore.mockResolvedValue({});
      mockScoringService.calculatePackageScore.mockResolvedValue(mockScore);

      const result = await service.recalculatePackageScore(1);

      expect(result).toEqual(expectedResult);
      expect(scoringService.calculatePackageScore).toHaveBeenCalledWith(1);
    });

    it('should throw NotFoundException for invalid package', async () => {
      mockPrismaService.package.findUnique.mockResolvedValue(null);

      await expect(service.recalculatePackageScore(999)).rejects.toThrow(NotFoundException);
    });
  });
});
