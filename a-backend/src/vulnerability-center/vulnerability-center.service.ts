import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { PrismaService } from '../prisma/prisma.service';
import { StigImportJobData } from '../queues/processors/stig-import.processor';
import { CciMappingJobData } from '../queues/processors/cci-mapping.processor';
import { ScoringService } from '../services/scoring.service';

@Injectable()
export class VulnerabilityCenterService {
  private readonly logger = new Logger(VulnerabilityCenterService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly scoringService: ScoringService,
    @InjectQueue('stig-import') private readonly stigImportQueue: Queue,
    @InjectQueue('cci-mapping') private readonly cciMappingQueue: Queue,
  ) {}

  async importStigScan(
    systemId: number,
    filename: string,
    fileContent: string,
    userId: number,
  ): Promise<{ jobId: string }> {
    // Validate system exists
    const system = await this.prisma.system.findUnique({
      where: { id: systemId },
    });

    if (!system) {
      throw new NotFoundException(`System with ID ${systemId} not found`);
    }

    // Create STIG import job
    const job = await this.stigImportQueue.add(
      'import-stig-scan',
      {
        systemId,
        filename,
        fileContent,
        userId,
      } as StigImportJobData,
      {
        removeOnComplete: 100,
        removeOnFail: 500,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
      },
    );

    this.logger.log(`Created STIG import job ${job.id} for system ${systemId}`);

    return { jobId: job.id || '' };
  }

  async getStigScans(systemId: number) {
    return this.prisma.stigScan.findMany({
      where: { systemId },
      include: {
        importer: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        systemScores: true,
        _count: {
          select: {
            stigFindings: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getStigFindings(
    systemId: number,
    scanId?: number,
    page = 1,
    limit = 50,
    filters: {
      status?: string;
      severity?: string;
      controlId?: string;
      search?: string;
    } = {},
  ) {
    // Cap the limit to prevent excessive memory usage
    const maxLimit = Math.min(limit, 10000);

    const skip = (page - 1) * maxLimit;

    const where: any = { systemId };

    if (scanId) {
      where.scanId = scanId;
    }

    if (filters.status) {
      where.status = filters.status;
    }

    if (filters.severity) {
      where.severity = filters.severity;
    }

    if (filters.controlId) {
      where.controlId = filters.controlId;
    }

    if (filters.search) {
      where.OR = [
        { vulnId: { contains: filters.search, mode: 'insensitive' } },
        { ruleTitle: { contains: filters.search, mode: 'insensitive' } },
        { ruleId: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    const [findings, total] = await Promise.all([
      this.prisma.stigFinding.findMany({
        where,
        include: {
          scan: {
            select: {
              id: true,
              filename: true,
              createdAt: true,
            },
          },
          reviewer: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
        },
        orderBy: [
          { severity: 'asc' }, // CAT_I first
          { status: 'asc' },   // Open first
          { ruleId: 'asc' },
        ],
        skip,
        take: maxLimit,
      }),
      this.prisma.stigFinding.count({ where }),
    ]);

    return {
      findings,
      pagination: {
        page,
        limit: maxLimit,
        total,
        pages: Math.ceil(total / maxLimit),
      },
    };
  }

  async updateFindingStatus(
    findingId: number,
    status: string,
    justification?: string,
    userId?: number,
  ) {
    const finding = await this.prisma.stigFinding.findUnique({
      where: { id: findingId },
    });

    if (!finding) {
      throw new NotFoundException(`Finding with ID ${findingId} not found`);
    }

    return this.prisma.stigFinding.update({
      where: { id: findingId },
      data: {
        status,
        justification,
        reviewedAt: new Date(),
        reviewedBy: userId,
      },
    });
  }

  async getSystemScore(systemId: number, scanId?: number) {
    const where: any = { systemId };
    if (scanId) {
      where.scanId = scanId;
    }

    return this.prisma.systemScore.findFirst({
      where,
      orderBy: { calculatedAt: 'desc' },
      include: {
        scan: {
          select: {
            id: true,
            filename: true,
            createdAt: true,
          },
        },
      },
    });
  }

  async getControlSystemStatus(systemId: number) {
    return this.prisma.controlSystemStatus.findMany({
      where: { systemId },
      orderBy: { controlId: 'asc' },
    });
  }

  async getJobStatus(jobId: string) {
    const job = await this.stigImportQueue.getJob(jobId);

    if (!job) {
      throw new NotFoundException(`Job with ID ${jobId} not found`);
    }

    return {
      id: job.id,
      name: job.name,
      progress: job.progress,
      processedOn: job.processedOn,
      finishedOn: job.finishedOn,
      failedReason: job.failedReason,
      returnvalue: job.returnvalue,
      opts: job.opts,
      data: job.data,
    };
  }

  async createStp(
    systemId: number,
    name: string,
    findingIds: number[],
    userId: number,
  ) {
    // Get findings to create test cases
    const findings = await this.prisma.stigFinding.findMany({
      where: {
        id: { in: findingIds },
        systemId,
        status: { in: ['Open', 'Not_Reviewed'] },
      },
    });

    if (findings.length === 0) {
      throw new NotFoundException('No valid findings found for STP creation');
    }

    // Create STP with test cases in a transaction
    return this.prisma.$transaction(async (tx) => {
      const stp = await tx.stp.create({
        data: {
          systemId,
          title: name,
          packageId: 1, // Default package for now
          createdBy: userId,
          testCases: {
            create: findings.map(finding => ({
              title: `Test ${finding.vulnId}: ${finding.ruleTitle}`,
              description: finding.findingDetails || '',
              testProcedure: finding.checkContent || '',
              expectedResult: 'Finding should be resolved',
            })),
          },
        },
        include: {
          testCases: true,
        },
      });

      // Update finding STP status
      await tx.stigFinding.updateMany({
        where: { id: { in: findingIds } },
        data: {
          stpStatus: 'Active',
          lastStpId: stp.id,
        },
      });

      return stp;
    });
  }

  async getGroupScore(groupId: number) {
    const latestScore = await this.prisma.groupScore.findFirst({
      where: { groupId },
      orderBy: { calculatedAt: 'desc' },
      include: {
        group: {
          select: {
            id: true,
            name: true,
            description: true,
          },
        },
        worstSystem: {
          select: {
            id: true,
            name: true,
            hostname: true,
          },
        },
      },
    });

    if (!latestScore) {
      // Try to calculate if missing
      await this.scoringService.calculateGroupScore(groupId);
      const calculatedScore = await this.prisma.groupScore.findFirst({
        where: { groupId },
        orderBy: { calculatedAt: 'desc' },
        include: {
          group: true,
          worstSystem: true,
        },
      });

      // If still no score after calculation, return empty score structure
      if (!calculatedScore) {
        const group = await this.prisma.group.findUnique({
          where: { id: groupId },
          select: { id: true, name: true, description: true }
        });

        return {
          id: null,
          groupId,
          assessmentCompleteness: 0,
          overallCompliance: 0,
          totalSystems: 0,
          completeAssessments: 0,
          highestSystemScore: 0,
          lowestSystemScore: 0,
          worstSystemId: null,
          worstSystemName: null,
          totalFindings: 0,
          openFindings: 0,
          notReviewedFindings: 0,
          catIOpen: 0,
          catIIOpen: 0,
          catIIIOpen: 0,
          controlsAffected: 0,
          controlsCompliant: 0,
          calculatedAt: new Date(),
          group,
          worstSystem: null,
        };
      }

      return calculatedScore;
    }

    return latestScore;
  }

  async getPackageScore(packageId: number) {
    const latestScore = await this.prisma.packageScore.findFirst({
      where: { packageId },
      orderBy: { calculatedAt: 'desc' },
      include: {
        package: {
          select: {
            id: true,
            name: true,
            description: true,
          },
        },
        worstGroup: {
          select: {
            id: true,
            name: true,
            description: true,
          },
        },
        worstSystem: {
          select: {
            id: true,
            name: true,
            hostname: true,
          },
        },
      },
    });

    if (!latestScore) {
      // Try to calculate if missing
      await this.scoringService.calculatePackageScore(packageId);
      const calculatedScore = await this.prisma.packageScore.findFirst({
        where: { packageId },
        orderBy: { calculatedAt: 'desc' },
        include: {
          package: true,
          worstGroup: true,
          worstSystem: true,
        },
      });

      // If still no score after calculation, return empty score structure
      if (!calculatedScore) {
        const pkg = await this.prisma.package.findUnique({
          where: { id: packageId },
          select: { id: true, name: true, description: true }
        });

        return {
          id: null,
          packageId,
          assessmentCompleteness: 0,
          overallCompliance: 0,
          totalGroups: 0,
          completeGroups: 0,
          highestGroupScore: 0,
          lowestGroupScore: 0,
          worstGroupId: null,
          worstGroupName: null,
          totalSystems: 0,
          completeAssessments: 0,
          worstSystemId: null,
          worstSystemName: null,
          totalFindings: 0,
          openFindings: 0,
          notReviewedFindings: 0,
          catITotal: 0,
          catIOpen: 0,
          catIITotal: 0,
          catIIOpen: 0,
          catIIITotal: 0,
          catIIIOpen: 0,
          controlsAffected: 0,
          controlsCompliant: 0,
          calculatedAt: new Date(),
          package: pkg,
          worstGroup: null,
          worstSystem: null,
        };
      }

      return calculatedScore;
    }

    return latestScore;
  }

  async getPackageStats(packageId: number) {
    // Get all systems in the package
    const systems = await this.prisma.system.findMany({
      where: {
        group: {
          packageId: packageId
        }
      },
      select: {
        id: true
      }
    });

    if (systems.length === 0) {
      // No systems, return zeros
      return {
        packageId,
        totalFindings: 0,
        criticalFindings: 0,
        highFindings: 0,
        mediumFindings: 0,
        lowFindings: 0,
        openItems: 0,
        complianceScore: 0,
        hasData: false
      };
    }

    // Count STIG findings for all systems in the package
    const systemIds = systems.map(s => s.id);

    const findingCounts = await this.prisma.stigFinding.groupBy({
      by: ['severity'],
      where: {
        systemId: { in: systemIds },
        status: { in: ['open', 'ongoing', 'not_reviewed'] }
      },
      _count: true
    });

    // Map severity counts
    const severityMap: Record<string, number> = {};
    let totalFindings = 0;

    findingCounts.forEach(item => {
      if (item.severity) {
        severityMap[item.severity.toLowerCase()] = item._count;
        totalFindings += item._count;
      }
    });

    // Get package score for compliance
    const packageScore = await this.prisma.packageScore.findFirst({
      where: { packageId },
      orderBy: { calculatedAt: 'desc' },
      select: {
        overallCompliance: true
      }
    });

    return {
      packageId,
      totalFindings,
      criticalFindings: severityMap['cat_i'] || 0,
      highFindings: severityMap['cat_ii'] || 0,
      mediumFindings: severityMap['cat_iii'] || 0,
      lowFindings: 0, // STIG doesn't have "low" severity
      openItems: totalFindings,
      complianceScore: packageScore?.overallCompliance || 0,
      hasData: totalFindings > 0
    };
  }

  async getControlGroupStatus(groupId: number) {
    const controlStatuses = await this.prisma.controlGroupStatus.findMany({
      where: { groupId },
      orderBy: { controlId: 'asc' },
    });

    if (controlStatuses.length === 0) {
      // Calculate if missing
      await this.scoringService.updateControlGroupStatus(groupId);
      return this.prisma.controlGroupStatus.findMany({
        where: { groupId },
        orderBy: { controlId: 'asc' },
      });
    }

    return controlStatuses;
  }

  async getControlPackageStatus(packageId: number) {
    return this.prisma.controlPackageStatus.findMany({
      where: { packageId },
      orderBy: { controlId: 'asc' },
    });
  }

  async recalculateGroupScore(groupId: number) {
    // Verify group exists
    const group = await this.prisma.group.findUnique({
      where: { id: groupId },
    });

    if (!group) {
      throw new NotFoundException(`Group with ID ${groupId} not found`);
    }

    // Recalculate scores for all systems in the group
    const systems = await this.prisma.system.findMany({
      where: { groupId },
    });

    for (const system of systems) {
      await this.scoringService.calculateSystemScore(system.id);
      await this.scoringService.updateControlSystemStatus(system.id);
    }

    // Recalculate group score
    await this.scoringService.calculateGroupScore(groupId);
    await this.scoringService.updateControlGroupStatus(groupId);

    return {
      success: true,
      message: `Group score recalculated for group ${groupId}`,
      systemsProcessed: systems.length,
    };
  }

  async recalculatePackageScore(packageId: number) {
    // Verify package exists
    const pkg = await this.prisma.package.findUnique({
      where: { id: packageId },
      include: {
        groups: true,
        systems: true,
      },
    });

    if (!pkg) {
      throw new NotFoundException(`Package with ID ${packageId} not found`);
    }

    // Recalculate scores for all groups in the package
    for (const group of pkg.groups) {
      await this.recalculateGroupScore(group.id);
    }

    // Recalculate package score
    await this.scoringService.calculatePackageScore(packageId);

    return {
      success: true,
      message: `Package score recalculated for package ${packageId}`,
      groupsProcessed: pkg.groups.length,
      systemsProcessed: pkg.systems.length,
    };
  }
}