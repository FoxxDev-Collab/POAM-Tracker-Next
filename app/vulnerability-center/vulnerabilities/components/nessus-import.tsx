"use client"

import { useState, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Checkbox } from "@/components/ui/checkbox"
import { ScrollArea } from "@/components/ui/scroll-area"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { 
  Upload, 
  FileCheck, 
  AlertCircle, 
  Server, 
  CheckCircle2,
  Database,
  Eye,
  X
} from "lucide-react"
import { cn } from "@/lib/utils"
import { toast } from "sonner"

type DetectedHost = {
  ip: string
  hostname?: string
  vulnerabilityCount: number
  matchedSystem?: {
    id: number
    name: string
    description?: string
  }
}

type ImportProgress = {
  phase: 'idle' | 'parsing' | 'matching' | 'importing' | 'complete'
  current: number
  total: number
  message: string
}

interface NessusImportProps {
  onImportComplete?: (results: { imported: number; systemId?: number }) => void
}

export function NessusImport({ onImportComplete }: NessusImportProps) {
  const [file, setFile] = useState<File | null>(null)
  const [detectedHosts, setDetectedHosts] = useState<DetectedHost[]>([])
  const [selectedHosts, setSelectedHosts] = useState<DetectedHost[]>([])
  const [showHostSelection, setShowHostSelection] = useState(false)
  const [importing, setImporting] = useState(false)
  const [progress, setProgress] = useState<ImportProgress>({
    phase: 'idle',
    current: 0,
    total: 0,
    message: ''
  })
  const [dragOver, setDragOver] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  // File selection handlers
  const handleFileSelect = (selectedFile: File | null) => {
    if (!selectedFile) return

    // Validate file type
    if (!selectedFile.name.endsWith('.nessus') && !selectedFile.type.includes('xml')) {
      toast.error('Please select a valid .nessus file')
      return
    }

    // Validate file size (max 100MB)
    if (selectedFile.size > 100 * 1024 * 1024) {
      toast.error('File size too large. Maximum size is 100MB.')
      return
    }

    setFile(selectedFile)
    setDetectedHosts([])
    setSelectedHosts([])
    setShowHostSelection(false)
  }

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    setDragOver(false)
    const droppedFile = e.dataTransfer.files[0]
    handleFileSelect(droppedFile)
  }

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    setDragOver(true)
  }

  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    setDragOver(false)
  }

  // Parse .nessus file to extract host information
  const parseNessusHosts = async (): Promise<DetectedHost[]> => {
    if (!file) return []

    setProgress({
      phase: 'parsing',
      current: 1,
      total: 3,
      message: 'Parsing Nessus file to extract hosts...'
    })

    try {
      const text = await file.text()
      const parser = new DOMParser()
      const xmlDoc = parser.parseFromString(text, 'text/xml')
      
      // Check for parsing errors
      const parseError = xmlDoc.getElementsByTagName('parsererror')[0]
      if (parseError) {
        throw new Error('Invalid XML format in .nessus file')
      }

      // Extract ReportHost elements
      const reportHosts = xmlDoc.getElementsByTagName('ReportHost')
      const hosts: DetectedHost[] = []

      for (let i = 0; i < reportHosts.length; i++) {
        const host = reportHosts[i]
        const hostName = host.getAttribute('name') || ''
        
        // Get hostname from HostProperties if available
        const hostProperties = host.getElementsByTagName('HostProperties')[0]
        let hostname = ''
        if (hostProperties) {
          const tags = hostProperties.getElementsByTagName('tag')
          for (let j = 0; j < tags.length; j++) {
            const tag = tags[j]
            if (tag.getAttribute('name') === 'host-fqdn' || tag.getAttribute('name') === 'netbios-name') {
              hostname = tag.textContent || ''
              break
            }
          }
        }

        // Count vulnerabilities (ReportItem elements)
        const vulnerabilities = host.getElementsByTagName('ReportItem')
        
        // Only include hosts that have vulnerabilities
        if (vulnerabilities.length > 0) {
          hosts.push({
            ip: hostName,
            hostname: hostname || undefined,
            vulnerabilityCount: vulnerabilities.length
          })
        }

        // Update progress
        setProgress({
          phase: 'parsing',
          current: Math.round((i + 1) / reportHosts.length * 100),
          total: 100,
          message: `Processing host ${i + 1} of ${reportHosts.length}...`
        })
      }

      console.log(`Parsed ${hosts.length} hosts with vulnerabilities from Nessus file`)
      return hosts

    } catch (error) {
      console.error('Error parsing Nessus file:', error)
      throw new Error(`Failed to parse Nessus file: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  // Match detected hosts with existing systems
  const matchHostsToSystems = async (hosts: DetectedHost[]): Promise<DetectedHost[]> => {
    setProgress({
      phase: 'matching',
      current: 1,
      total: 3,
      message: 'Matching hosts to existing systems...'
    })

    try {
      // Get all host IPs for bulk lookup
      const hostIPs = hosts.map(h => h.ip)
      
      const response = await fetch('/api/systems/match-hosts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ips: hostIPs })
      })

      if (!response.ok) {
        throw new Error(`Failed to match hosts: ${response.statusText}`)
      }

      const matchedSystems = await response.json()
      console.log('Matched systems:', matchedSystems)

      // Update hosts with matched system information
      const hostsWithMatches = hosts.map(host => ({
        ...host,
        matchedSystem: matchedSystems.find((sys: any) => sys.ipAddress === host.ip)
      }))

      const matchedCount = hostsWithMatches.filter(h => h.matchedSystem).length
      console.log(`Matched ${matchedCount} of ${hosts.length} hosts to existing systems`)

      return hostsWithMatches

    } catch (error) {
      console.error('Error matching hosts:', error)
      // Return hosts without matches if matching fails
      return hosts
    }
  }

  // Start the import process
  const handleStartImport = async () => {
    if (!file) return

    setImporting(true)

    try {
      // Step 1: Parse hosts
      const hosts = await parseNessusHosts()
      
      if (hosts.length === 0) {
        toast.error('No hosts with vulnerabilities found in the Nessus file')
        setImporting(false)
        return
      }

      // Step 2: Match to systems
      const hostsWithMatches = await matchHostsToSystems(hosts)
      
      setDetectedHosts(hostsWithMatches)
      
      // Step 3: Show host selection dialog
      setProgress({
        phase: 'matching',
        current: 3,
        total: 3,
        message: `Found ${hostsWithMatches.length} hosts. Select which hosts to import.`
      })
      
      // Auto-select hosts that matched existing systems
      const autoSelected = hostsWithMatches.filter(h => h.matchedSystem)
      setSelectedHosts(autoSelected)
      
      setShowHostSelection(true)
      setImporting(false)

    } catch (error) {
      console.error('Import error:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to process Nessus file')
      setImporting(false)
    }
  }

  // Import selected hosts
  const handleImportSelected = async () => {
    if (selectedHosts.length === 0) {
      toast.error('Please select at least one host to import')
      return
    }

    setImporting(true)
    setShowHostSelection(false)

    try {
      setProgress({
        phase: 'importing',
        current: 0,
        total: selectedHosts.length,
        message: 'Importing vulnerability data...'
      })

      const formData = new FormData()
      formData.append('file', file!)
      formData.append('selectedHosts', JSON.stringify(selectedHosts.map(h => ({
        ip: h.ip,
        systemId: h.matchedSystem?.id
      }))))

      const response = await fetch('/api/vulnerabilities/nessus/import', {
        method: 'POST',
        body: formData
      })

      if (!response.ok) {
        throw new Error(`Import failed: ${response.statusText}`)
      }

      const result = await response.json()
      console.log('Import completed:', result)

      setProgress({
        phase: 'complete',
        current: selectedHosts.length,
        total: selectedHosts.length,
        message: `Successfully imported ${result.imported || 0} vulnerabilities`
      })

      toast.success(`Import complete! Processed ${result.imported || 0} vulnerabilities for ${selectedHosts.length} host(s)`)
      
      // Reset state
      setFile(null)
      setDetectedHosts([])
      setSelectedHosts([])
      
      // Notify parent component
      if (onImportComplete) {
        onImportComplete({
          imported: result.imported || 0,
          systemId: selectedHosts[0]?.matchedSystem?.id
        })
      }

      // Notify other components to refresh
      window.dispatchEvent(new CustomEvent('nessus-imported', { 
        detail: { imported: result.imported, selectedHosts } 
      }))

    } catch (error) {
      console.error('Import error:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to import Nessus data')
    } finally {
      setImporting(false)
    }
  }

  const getSeverityColor = (count: number) => {
    if (count === 0) return 'text-green-600'
    if (count < 10) return 'text-yellow-600'
    if (count < 50) return 'text-orange-600'
    return 'text-red-600'
  }

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Database className="h-5 w-5" />
            Smart Nessus Import
          </CardTitle>
          <CardDescription>
            Upload a .nessus file and intelligently match vulnerabilities to your existing systems
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* File Upload Area */}
          <div
            className={cn(
              "border-2 border-dashed rounded-lg p-8 text-center transition-colors",
              dragOver ? "border-primary bg-primary/5" : "border-muted-foreground/25",
              file ? "border-green-500 bg-green-50" : ""
            )}
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
          >
            {file ? (
              <div className="space-y-2">
                <FileCheck className="h-8 w-8 text-green-600 mx-auto" />
                <div className="font-medium text-green-800">{file.name}</div>
                <div className="text-sm text-green-600">
                  {(file.size / (1024 * 1024)).toFixed(1)} MB
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setFile(null)}
                  className="mt-2"
                >
                  <X className="h-4 w-4 mr-1" />
                  Remove
                </Button>
              </div>
            ) : (
              <div className="space-y-3">
                <Upload className="h-12 w-12 text-muted-foreground mx-auto" />
                <div>
                  <p className="text-lg font-medium">Drop .nessus file here</p>
                  <p className="text-sm text-muted-foreground">or click to browse</p>
                </div>
                <input
                  ref={fileInputRef}
                  type="file"
                  accept=".nessus,application/xml,text/xml"
                  className="hidden"
                  onChange={(e) => handleFileSelect(e.target.files?.[0] || null)}
                />
                <Button
                  variant="outline"
                  onClick={() => fileInputRef.current?.click()}
                >
                  Choose File
                </Button>
              </div>
            )}
          </div>

          {/* Progress Indicator */}
          {importing && (
            <div className="space-y-2">
              <div className="flex items-center justify-between text-sm">
                <span className="font-medium">{progress.message}</span>
                <span>{progress.current}/{progress.total}</span>
              </div>
              <Progress 
                value={progress.total > 0 ? (progress.current / progress.total) * 100 : 0} 
                className="h-2" 
              />
            </div>
          )}

          {/* Action Button */}
          <div className="flex justify-center">
            <Button
              onClick={handleStartImport}
              disabled={!file || importing}
              className="min-w-32"
            >
              {importing ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full" />
                  Processing...
                </div>
              ) : (
                <>
                  <Eye className="h-4 w-4 mr-2" />
                  Analyze File
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Host Selection Dialog */}
      <Dialog open={showHostSelection} onOpenChange={setShowHostSelection}>
        <DialogContent className="max-w-4xl max-h-[80vh]">
          <DialogHeader>
            <DialogTitle>Select Hosts to Import</DialogTitle>
            <DialogDescription>
              We found {detectedHosts.length} hosts in the Nessus scan. 
              Select which hosts you'd like to import vulnerability data for.
            </DialogDescription>
          </DialogHeader>

          <ScrollArea className="max-h-96 pr-4">
            <div className="space-y-3">
              {detectedHosts.map((host, index) => {
                const isSelected = selectedHosts.some(h => h.ip === host.ip)
                
                return (
                  <div
                    key={host.ip}
                    className={cn(
                      "p-4 border rounded-lg transition-colors",
                      isSelected ? "border-primary bg-primary/5" : "border-border",
                      host.matchedSystem ? "bg-green-50 border-green-200" : ""
                    )}
                  >
                    <div className="flex items-start gap-3">
                      <Checkbox
                        checked={isSelected}
                        onCheckedChange={(checked) => {
                          if (checked) {
                            setSelectedHosts(prev => [...prev, host])
                          } else {
                            setSelectedHosts(prev => prev.filter(h => h.ip !== host.ip))
                          }
                        }}
                      />
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-2">
                          <Server className="h-4 w-4 text-muted-foreground" />
                          <span className="font-medium">{host.ip}</span>
                          {host.hostname && (
                            <Badge variant="outline" className="text-xs">
                              {host.hostname}
                            </Badge>
                          )}
                          <Badge 
                            variant="outline" 
                            className={cn("text-xs", getSeverityColor(host.vulnerabilityCount))}
                          >
                            {host.vulnerabilityCount} findings
                          </Badge>
                        </div>
                        
                        {host.matchedSystem ? (
                          <div className="flex items-center gap-2 text-sm text-green-700">
                            <CheckCircle2 className="h-4 w-4" />
                            <span>
                              Matched to system: <strong>{host.matchedSystem.name}</strong>
                            </span>
                          </div>
                        ) : (
                          <div className="flex items-center gap-2 text-sm text-orange-600">
                            <AlertCircle className="h-4 w-4" />
                            <span>No matching system found - will create new vulnerability records</span>
                          </div>
                        )}
                        
                        {host.matchedSystem?.description && (
                          <p className="text-xs text-muted-foreground mt-1">
                            {host.matchedSystem.description}
                          </p>
                        )}
                      </div>
                    </div>
                  </div>
                )
              })}
            </div>
          </ScrollArea>

          <DialogFooter>
            <div className="flex items-center justify-between w-full">
              <div className="text-sm text-muted-foreground">
                {selectedHosts.length} of {detectedHosts.length} hosts selected
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  onClick={() => setShowHostSelection(false)}
                >
                  Cancel
                </Button>
                <Button
                  onClick={handleImportSelected}
                  disabled={selectedHosts.length === 0 || importing}
                >
                  {importing ? (
                    <div className="flex items-center gap-2">
                      <div className="animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full" />
                      Importing...
                    </div>
                  ) : (
                    <>
                      Import {selectedHosts.length} Host{selectedHosts.length !== 1 ? 's' : ''}
                    </>
                  )}
                </Button>
              </div>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}